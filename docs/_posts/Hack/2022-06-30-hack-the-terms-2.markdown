---
layout: post
title: "Hack🪓 the #2 Promise"
date: 2022-06-20 18:50:00 +0900
categories: [Hack]
---

## 내가 JS를 배운 방식

![내가 JS를 배운 방식](https://i.postimg.cc/brTsMb5m/js.png)  
{: .center}

사실 나도 2017년 경에 C#과 디자인 패턴 등을 배울 때만 해도 책이나 참고자료 보면서 차근차근 배우는게 가능했었다. 그런데 어느 순간 부터 성인 ADHD라도 발병한건지 그렇게 한 걸음씩 하는걸 몸이 견디질 못하더라. 그래서 근래에 들어서는 그냥 새로운 기술, 언어를 배울 때 어느정도 들이박는 식으로 시작하고 있다. 일단 만들어보자는 식으로. 이런 말도 있잖아.

> 만들기 위해 배우지 말고 배우기 위해 만들어라. {실용주의 사고와 학습}

다짜고짜 왜 이런 이야기로 시작했느냐. 이렇게 배워온 탓인지 그냥 습관적으로 써온 키워드들이 가끔씩 내게 어색하게 다가올 때가 있다. 예를 들자면 이런거:

## Promise

![약속해줘](https://i.postimg.cc/B6b1MHd4/image.png)  
뻔하지만 이것만한게 또 없어요
{: .center}

특히나 **"Promise"**란 단어는 아무래도 초등 교육 받을 꼬꼬마 시절부터 **"약속하다"**로 각인되어 있는 바람에, 나는 이걸 쓸 때 마다 이 사람들이 왜 **"약속"**을 비동기 처리 테크닉의 이름으로 사용했을까 하는 의문이 생기기 시작한 것이다. 그래서 준비한 [의존성 주입](https://anteater333.github.io/hack/2022/03/07/hack-the-terms-1.html) 이후 두 번째 분석 대상. **Promise**{: .middle-big}를 지금부터 뜯어보자.

## 왜 자바스크립트인가?

![인기언어](https://i.postimg.cc/xTLVgqCd/image.png)  
[출처](https://twitter.com/dylayed/status/1539659879706529793?t=38gF-WtspHSPd-DCWy2H8w&s=09)  
{: .center}

우선은 간단한 역사 공부. 자바스크립트는 1990년대에 처음 등장해 어떻게 2020년대에 가장 많은 사용자를 가진 언어 중 하나가 되었을까. 결론부터 이야기 하자면, 웹은 너무 성공했고, 웹 브라우저의 존재감은 덩달아 거대해졌으며, 자바스크립트는 태초부터 웹 브라우저를 위한 언어였다.

보통 웹(Web)으로 말하는 월드 와이드 웹(World Wide Web)은 기본적으로 HTML이라는 정적인 마크업 언어로 작성된 문서를 공유하는 시스템이었다. 전 세계의 사람들이 적절한 인프라만 갖춰지면 쉽게 문서를 주고받을 수 있다는 점은 아무래도 엄청난 매력 포인트였을테고, 곧 사람들은 더 재미있는 문서를 만드는 방법에 대해 몰두하게 되었으리라. 그 결과로 웹 브라우저 개발사는 정적인 마크업 언어의 한계를 보완할 수 있도록 동적인 프로그래밍 언어를 [글루 코드](https://en.wikipedia.org/wiki/Glue_code)로써 도입하길 시작하였고, 기존의 프로그래밍 언어를 사용하려는 몇 번의 시도 이후 웹 브라우저를 위해 설계된 프로그래밍 언어 자바스크립트를 탄생시킨 것이다.

이런 배경을 가진 자바스크립트의 특징을 모두 나열하기엔, 나도 사실 잘 모르기도 하고, 주제가 자바스크립트가 되어버릴 것 같으니 중요한 부분에 집중해보자.

## 비동기非同期Asynchronous

![기다리는중](https://i.postimg.cc/GhZpdNSC/image.jpg)  
사실은 이미 얼어죽은거죠
{: .center}

요점은 자바스크립트는 GUI(HTML)를 다루는 언어로서 탄생했다는 것이고, GUI는 얼어붙은 채 있으면 안된다는 것이다. 긴 대기 시간이 필요한 작업을 수행하면 화면이 얼어붙는게 아니라 최소한 사용자에게 빙빙 돌아가는 로딩 인디케이터라도 보여줘야 한다. 이것이 바로 **비동기(Asynchronous)** 방식의 프로그래밍이다: 사람은 결과를 기다려도 프로그램이 결과를 기다리지는 않는다.

자바스크립트는 비동기 처리에 유리한 구조를 가지고 있다. 비동기 처리는 항상 자바스크립트의 주요 관심사 중 하나였으며, 자바스크립트의 발전에 따라 비동기 처리의 구현 방식 또한 발전해왔다.

## 일급 함수

자바스크립트의 비동기 처리가 어떻게 발전했는지 알아보기 전에, 자바스크립트가 비동기 처리에 유리한 구조를 가지고 있다고 했는데, 그 "유리한 구조"란 무엇인지 먼저 알아두고 가자. 자바스크립트의 함수는 "일급 함수(First-class function)"이다. 프로그래밍 언어를 구성하는 객체들은 모두 평등하나 어떤 객체들은 **좀 더 평등**하다. 그들은 값을 할당 받을 수 있고, 비교 연산의 대상이 될 수 있고, 함수에 매개변수로써 전달될 수 있으며 함수의 반환 값이 될 수 있다. 이것을 "일급 객체"라고 하며, 이름에서 유추할 수 있듯이 "일급 함수"인 자바스크립트의 함수는 위에서 나열한 모든 행동들의 대상이 될 수 있다. 간단히 말해서, **자바스크립트에선 함수를 변수 처럼 쓸 수 있다.**

{% highlight javascript %}
// 매개변수로 함수를 받는 함수
function doSomething(value, something) {
  const calculated = value + 5;

  // 매개변수로 전달받은 함수 something을 실행
  const result = something(calculated);

  return result;
}

// 변수에 할당한 함수 (익명함수를 변수에 할당)
const myFunction = function (value) {
  const calculated = value + 10;

  // 함수의 결과물로 새로운 함수를 반환
  return function rtFunction(anotherValue) {
    console.log(calculated + anotherValue);
  };
};

// myFunction을 전달해 doSomething 함수를 실행한 결과값을 변수에 할당
const result = doSomething(1, myFunction);

// 짜잔 전달받은 결과값은 함수였습니다!
result(100);

// console에 116이 출력됩니다.
{% endhighlight %}

위의 간단한 텅 트위스터 느낌의 예제를 보자. 자바스크립트에선 이렇게 함수를 자유자재로 사용할 수 있다. 이것이 의미하는 것은 무엇인가, 우리는 행동을 위임할 수 있게 되었다.

## 자바스크립트 비동기 처리의 발전

![비동기 처리의 발전](https://i.postimg.cc/PJ0nc6Nh/asynchronous.png)  
[출처](https://www.johnpapa.net/async-comparisons/)  
{: .center}

### Callback

{% highlight javascript %}
setTimeout(TheCALLBACK, 1000);
{% endhighlight %}

`setTimeout`은 지정한 시간 뒤에 특정 함수를 실행해주는 자바스크립트 내장 함수이다. 위 코드를 한국말로 바꾸면, "1000 밀리 초 이후에 `TheCALLBACK` 함수를 실행시켜"이다. **Callback, 콜백 함수**는 이처럼 다른 함수에 매개변수로 전달해 전달 받은 함수가 자신을 실행할 수 있도록 하는 함수를 뜻한다. 콜백 함수를 전달받는 `setTimeout`은 비동기 함수라고 부르자. 비동기 함수에 콜백 함수를 전달함으로써 비동기 함수의 로직을 프로그램이 기다릴 필요 없이 비동기 함수 이후에 콜백 함수가 실행된다는 순서가 지켜지게끔 만들 수 있는 것이다. 이 콜백 함수가 바로 자바스크립트의 첫 번째 비동기 처리 방식이다.

좀 더 개선 필요