---
layout: post
title: "자잘한 도움말 #14 웹 페이지의 장치 화면 절전 방지 구현하기"
subtitle: "Screen Wake Lock API"
description: "JavaScript, 웹 페이지 화면 절전, 화면 절전 막기, 절전 모드, 슬립 모드, 슬립 모드 진입 방지, Wake Lock, wakeLock, Screen Wake Lock API, 기기를 켜진 상태로 유지, 화면 자동 꺼짐 방지, PWA, PWA 화면 절전, PWA 슬립 모드, 프로그레시브 웹 앱, 프로그레시브 웹 어플리케이션, 프로그레시브 웹 애플리케이션, Progressive Web Application"
date: 2024-02-17 23:46:00 +0900
categories: [Micro]
---

## TL;DR

- 화면 절전 방지는 **Wake Lock**이라고 부른다.
- Web API [**Screen Wake Lock API**](https://developer.mozilla.org/en-US/docs/Web/API/Screen_Wake_Lock_API)를 사용한다.
  ```javascript
  // Wake Lock 활성화
  navigator.wakeLock.request("screen").then((wakeLock) => {
    // do something
  })

  // Wake Lock 비활성화 (변수 wakeLock은 활성화 단계에서 얻어낸 오브젝트)
  wakeLock.release().then(() => {
    // do something
  });
  ```
- 2024년 2월 기준 아직 해당 API를 지원하지 않는 브라우저들이 있기 때문에 기능 구현 시 지원 여부를 확인해야 한다.
  ```javascript
  isSupported = "wakeLock" in navigator;
  ```
- Screen Wake Lock API는 [보안 컨텍스트(Secure contexts)](https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts)에서만 제공된다.
  - HTTPS 혹은 로컬 호스트를 나타내는 URL에 접속할 때에만 제공된다.
  - 테스트 시 장치가 서버에 보안 컨텍스트 상황에 맞게 접속하고 있는지 확인해야 한다.
    - 특정 브라우저에서는 로컬 호스트를 보안 컨텍스트로 인식하지 못할수도 있다.

---

## 이하 그리 중요하진 않은 내용들

![PWA](https://i.postimg.cc/bwJN0nqD/image.png){:loading="lazy"}  
{: .center}

오늘 주제는 PWA의 일부분을 다룬다. PWA라고 하니 뭔가 거창한 이야기를 해야 할 것 같지만, 사실 나도 PWA에 대해서는 잘 모른다. 웹과 네이티브 모두의 장점을 가지는 웹 어플리케이션이라는 개념 정도? 근데 이걸 달리 말하면, PWA를 위해선 웹 개발자가 웹과 네이티브 모두의 장점을 신경써가며 기능을 구현해야 한다는 말이기도 하겠지. 이번 주제 화면 절전 방지처럼, 웹 앱인데 네이티브 앱인것 마냥 장치를 직접 제어할 수 있도록 만들어야 한다던가. 문득 PWA는 특정 기술이나 도구를 칭한다기보다는, 개발 지침 혹은 패러다임에 가깝다는 생각이 든다. 아무튼, 글을 시작하기에 앞서 딱히 할 말이 없어서 생각나는대로 적어봤다. PWA에 대해서 이 글에서는 더이상 언급할 일은 없을 것 같으니 자세한 정보를 원한다면 다른 글을 읽어보도록 하자. 좋은 글이 많더라고.

### 화면 절전

[![도마도](https://raw.githubusercontent.com/anteater333/domado/main/docs/screen.png){:loading="lazy"}  
도마도 뽀모도로 타이머](https://domado.vercel.app/)
{: .center .rounded-edge-16}

최근 열심히 여기저기 끼워팔고 있는 내 토이 프로젝트 도마도. 작년 말부터 뽀모도로 타이머 어플 하나 잘 쓰고 있었는데 갑자기 그게 나보고 쓰던 기능들 계속 쓰고 싶으면 결제하라고 하더라고. 그깟 타이머 만드는거 뭐가 어렵다고 내가 만들고 말지. 라는 생각으로 시작했고 벌써 한달 넘게 이걸 붙잡고 있네.. 아니 사실 이미 어느정도 혼자 만족해하며 쓸 수 있는 수준까진 만들어놨고, 공개된 서버에 배포도 되어있긴 하다. 그냥 손 털고 다시 할거 하러 가도 되는 상황인데, 디자인이 이쁘게 나와서 그런가, 계속 미련을 가지고 기능들을 덧붙이고 있다.

이렇게 작고 쪼잔한 마인드에서 출발한 프로젝트였기에 PC를 제외한 다른 장치에 대한 고려가 부족했던건 사실이다. 뒤늦게 페이지에 반응형 디자인을 적용하고 내 휴대폰에서 태스트를 시작했더니, 25분 타이머가 다 가기도 전에 갑자기 꺼지는 내 휴대폰의 화면. 모바일 디바이스는 배터리가 소중해요. 쓰지도 않는 디스플레이 뭐하러 켜두니. 하지만 애석하게도 아직까지 나의 도마도는 백그라운드에서 타이머가 제대로 동작하지 않는다. 물론 그 기능도 지금 열심히 구현하려고 정보를 찾아보고 있다. 하지만 일단 더 쉬워 보이는 길부터 가보자. 그냥 화면이 꺼지지 않게 만들면 되잖아.

![옵션](https://i.postimg.cc/NFJWkTwB/image.png){:loading="lazy"}  
이 옵션을 추가하는게 이번 목표  
{: .center .w-3-quarter .rounded-edge-16}

### Screen Wake Lock API

### Screen Wake Lock API를 사용하는 React Custom Hook 만들기

## 내가 배운 것

---

- Screen Wake Lock API
  - 웹 페이지에 화면 자동 꺼짐 방지 기능을 넣자
  - https://developer.mozilla.org/en-US/docs/Web/API/Screen_Wake_Lock_API
  - 커스텀 React Hook (from DoMaDo)
    - 생길 수 있는 문제에 대해 설명하기
    - 여러 웹 워커에 의해 요청이 올 수 있으므로 인스턴스를 생성하는 방식
    - DOMException: The requesting page is not visible


```typescript
import { useCallback, useEffect, useState } from 'react';

export const useWakeLock = () => {
  const [wakeLock, setWakeLock] = useState<WakeLockSentinel | null>(null);

  /** 각 callback들이 직접 조작하지 않고 useEffect 훅에서 WakeLock을 조작할 수 있도록 별도 상태 선언 */
  const [wakeLockStatus, setWakeLockStatus] = useState<
    'requested' | 'released' | 'idle'
  >('idle');

  const isSupported = 'wakeLock' in navigator;

  /** 경고 문구 출력 hook (개발자 참고용) */
  useEffect(() => {
    if (!isSupported)
      console.log(
        'DoMaDo: 현재 브라우저는 Screen Wake Lock API를 지원하지 않습니다.\nhttps://developer.mozilla.org/en-US/docs/Web/API/Screen_Wake_Lock_API',
      );
  }, [isSupported]);

  /** 실질적으로 Wake Lock을 변경하는 useEffect 훅 (core 로직) */
  useEffect(() => {
    // known issue.
    // requested case가 발생한 순간에 웹 페이지의 탭이 백그라운드에 위치할 시 DOMException을 발생시킴.
    // 에러 타입에 대한 조사 후 handling 필요.
    switch (wakeLockStatus) {
      case 'requested':
        if (!isSupported) setWakeLockStatus('idle');
        else
          navigator.wakeLock.request('screen').then((newWakeLock) => {
            setWakeLock((prevWakeLock) => {
              prevWakeLock?.release();
              setWakeLockStatus('idle');
              return newWakeLock;
            });
          });
        break;
      case 'released':
        if (!wakeLock) setWakeLockStatus('idle');
        else
          wakeLock.release().then(() => {
            setWakeLock(null);
            setWakeLockStatus('idle');
          });
        break;
    }
  }, [wakeLock, wakeLockStatus, isSupported]);

  /** Wake Lock을 사용하는 상태로 변경, API 형태로 포장 */
  const requestWakeLock = useCallback(() => {
    setWakeLockStatus('requested');
  }, []);

  /** Wake Lock을 사용하지 않는 상태로 변경, API 형태로 포장 */
  const releaseWakeLock = useCallback(() => {
    setWakeLockStatus('released');
  }, []);

  return {
    /** Wake Lock 사용 */
    requestWakeLock,
    /** Wake Lock 해제 */
    releaseWakeLock,
    /** 현재 웹 브라우저의 기능 지원 여부 */
    isSupported,
  };
};
```