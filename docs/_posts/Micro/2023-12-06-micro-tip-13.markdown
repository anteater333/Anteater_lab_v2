---
layout: post
title: "자잘한 도움말 #13 Javascript에서 중첩된 구조에 대한 깊은 복사"
subtitle: "structuredClone() 쓰세요."
description: ""
date: 2023-12-06 11:00:00 +0900
categories: [Micro]
---

## TL;DR

- 참조 타입의 얕은 복사 vs 깊은 복사
  - 얕은 복사 : 데이터의 주소만 복사한다.
  - 깊은 복사 : 데이터의 값을 복사해 새로운 메모리에 할당한다.
- 중첩 구조를 가지는 객체에 대해서는 제대로 된 깊은 복사를 구현하기 까다롭다.
  ```javascript
  const original = { a: 1, b: 2, c: new Date() };
  const deepCopied = JSON.parse(JSON.stringify(original));
  // deepCopied.c는 문자열
  ```
  - 이렇게 `JSON.parse()`와 `JSON.stringify()`를 사용해 구현할 순 있지만 특정 상황에서 제대로 동작하지 않을 수 있다.

- Web API [`structuredClone()`](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone)을 사용하자.  
  ```javascript
  const original = { a: 1, b: 2, c: new Date() };
  const deepCopied = structuredClone(original);
  // deepCopied.c는 Date 객체
  ```
- 2023년 기준 비교적 최신 기술이기 때문에 사용 중인 자바스크립트 실행 환경의 [지원 현황](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone#browser_compatibility)을 확인하고 사용해야 한다.
  - 대표적으로 node.js는 17 버전부터 지원한다.
  - [백준의 node.js 버전은 2023년 기준 v16.13.1이기 때문에](https://help.acmicpc.net/language/info) 이 API를 사용할 수 없다.

---

## 이하 그리 중요하진 않은 내용들

![안깊어요^^](https://i.postimg.cc/L8mGm1wL/image.png)  
{: .center .rounded-edge-16}

복사된 것은 값인가, 주소인가. 앞서서 몇 번 이 주제와 관련된 글을 썼던 기억이 난다. 그래서 어차피 개념은 익숙해보이고, 그냥 API 하나 소개하면 되겠거니 살짝 정보의 바다에 발을 담궈봤는데, 생각보다 그 깊이가 깊어서 조금 당황하고 있다. 아무튼 이 "자잘한 도움말" 카테고리의 여느 글들과 다를 바 없이 아래 내용들은 굳이 읽을 필요 없다는 점을 미리 언급하고 시작하겠다. 특히 이번처럼 나 스스로도 자신이 없는 경우엔 더...

### 얕은 복사 vs 깊은 복사

데이터는 크게 두 유형으로 나뉘어진다. 숫자나 문자열 같은 기본형(Primitive) 데이터와 배열이나 객체같은 참조형(Reference) 데이터. [예전 글](/micro/2022/01/18/micro-tip-3.html)에서 이 두 종류의 데이터가 함수에 전달되었을 때의 행동에 대해 정리했던 적이 있다. 간단히 요약하자면, 기본형 데이터는 값 그 자체가 전달되기 때문에 함수 내부에서 그 데이터를 담고 있는 변수에 변화가 생겨도 밖의 변수에는 변화가 반영되지 않는다. 참조형 데이터는 그 데이터의 주소값이 전달(Object references are passed by value), 함수 내부에서 그 주소를 통해 데이터에 접근하기 때문에 원본 데이터에도 영향이 갈 수 있다. 여기서 "전달"은 다시말해 "복사"라고 할 수 있다. 현재 스코프의 데이터를 복사해서 새 스코프(함수)에 전달한다는 개념. 기본형 데이터에선 데이터 그 자체가 복사된다. 참조형 데이터에서는 주소만 복사된다.

![당연히 말이되죠](https://i.postimg.cc/GmPL4X8g/image.gif)  
그럼 참조형 데이터의 데이터를 복사하는건?
{: .center .rounded-edge}

이번 문제는 '그러면 우리는 참조형 데이터에 대해선 항상 주소를 복사할 수 밖에 없는 것인가' 라는 질문에서 시작된다. 당연히 가능하다. 참조형 데이터에 대한 복사는 두 가지 방식으로 나눌 수 있다.

![얕은 vs 깊은](https://i.postimg.cc/ZRtmLgBh/image.png)  
배열에 대한 얕은 복사 vs 깊은 복사
{: .center .rounded-edge-16}

- **얕은 복사** : 주소를 복사. 데이터는 그대로, 변수만 하나 더 생긴다.
- **깊은 복사** : 값을 복사. 그리고 새로운 메모리 공간을 사용한다.

Javascript에서 기초적인 형태의 깊은 복사는 다음과 같이 구현할 수 있다. 배열 혹은 객체를 순환하면서 그 값들을 하나씩 복사해주면 된다.

```javascript
/**
 * 원본 객체
 */
const original = {
  name: "anteater",
  age: "16 (for real)",
  gender: "male",
  likes: ["singing", "games"],
};

/**
 * 간단한 깊은 복사 함수
 */
function easyDeepCopy(obj) {
  const newObj = {};
  for (const key in obj) {
    newObj[key] = obj[key];
  }
  return newObj;
}

/** 얕은 복사한 객체 */
const shallowClone = original;

/** 깊은 복사한 객체 */
const deepClone = easyDeepCopy(original);

// 원본 객체의 값을 변경
original.age = 29;

// 얕게 복사한 객체도 값이 변경됨
console.log(shallowClone.age); // 출력 결과 : 29
// 깊게 복사한 객체엔 변경이 반영되지 않음
console.log(deepClone.age); // 출력 결과 : "16 (for real)"
```

### 중첩된 구조에 대한 깊은 복사

위 함수는 특정한 상황에만 제대로 동작할 것이다. 객체가 아닌 배열이 들어온다면? 이건 뭐 배열이 들어올 땐 `in` 대신 `of`를 쓰면 되겠지만. 참조형 데이터 안에 또다른 참조형 데이터가 들어있다면? 위 코드 아래쪽에 다음 두 줄을 추가해보자.

```javascript
original.likes.push("movies");
console.log(deepClone.likes); // 출력 결과 : [ 'singing', 'games', 'movies' ]
// 깊은 복사한 객체도 영향을 받는다!
```

이처럼 중첩된 구조에 대해선 깊은 복사를 수행하기가 까다롭다. 우리는 다음 두 조건을 만족하는 복사 로직을 만들어야 한다.

1. 깊어야 함: 원본 구조 전체에 대해서 깊은 복사가 수행되어야 한다. 예를 들어 숫자, 문자열만 깊은 복사 처리되고 자식으로 포함된 객체는 여전히 주소만 복사되면 안된다.
2. 복사여야 함: 데이터의 형태가 변경되면 안된다. AS-IS. 예를 들어 임의의 클래스로 선언했던 값이 복사 과정에서 문자열로 변환되어선 안된다.

#### 고전적 방식

일단 고전적인 방식부터 알아보자. 구조를 직접 순회하는 것은 기존 방식과 같되, 내부에 소속된 참조형 데이터에 대해 다시 깊은 복사를 적용할 수 있도록 재귀 함수를 사용한다.

```javascript
/**
 * 제대로 된(?) 깊은 복사
 */
function deepCopy(obj) {
  if (typeof obj !== "object" || obj === null) {
    return obj; // 기본형 데이터는 그대로 반환
  }

  if (Array.isArray(obj)) {
    // 배열에 대한 깊은 복사
    const newArray = [];
    for (let data of obj) {
      newArray.push(deepCopy(data)); // 재귀
    }

    return newArray;
  } else {
    // 객체에 대한 깊은 복사
    const newObj = {};
    for (let key in obj) {
      newObj[key] = deepCopy(obj[key]); // 재귀
    }

    return newObj;
  }
}
```

그리고 또다른 널리 알려진 방법도 있다. `JSON.parse(JSON.stringify(obj))`. 직접 객체를 순회하는 것이 아니라 데이터를 통째로 문자열로 만들어 상수화한 다음 그걸 다시 JSON으로 파싱해 새 객체로 만드는 방법이다. 약간 편법 같으면서도 꽤 잘 동작한다.

```javascript
const original = {
  name: "anteater",
  age: "16 (for real)",
  gender: "male",
  likes: ["singing", "games"],
  etc: {
    home: "Daegu",
    budget: 0,
  },
  createdAt: new Date("1995-04-07"),
};

/** 직접 구현한 깊은 복사 */
const copiedObj = deepCopy(original);
/** JSON 활용 깊은 복사 */ 
const copied2Obj = JSON.parse(JSON.stringify(original));

original.likes.push("movies");
original.etc.budget = 10000;

// 중첩된 구조에 대해서도 깊은 복사 성공
console.log(copiedObj.likes); // 출력 결과 : [ 'singing', 'games' ]
console.log(copiedObj.etc.budget); // 출력 결과 : 0
console.log(copied2Obj.likes); // 출력 결과 : [ 'singing', 'games' ]
console.log(copied2Obj.etc.budget); // 출력 결과 : 0
```

하지만 이 방법들도 완벽하진 않다. 아래 테스트 케이스를 보자.

```javascript
// 이건 어떠냐
console.log(original.createdAt); // 출력 결과 : 1995-04-07T00:00:00.000Z (Date 객체)
console.log(copiedObj.createdAt); // 출력 결과 : {}
console.log(copied2Obj.createdAt); // 출력 결과 : 1995-04-07T00:00:00.000Z (문자열)
```

직접 구현한 함수는 Date 객체를 제대로 복사하지 못하고, JSON을 활용한 방법에선 출력은 제대로 된 것 처럼 보이지만 객체가 아니라 문자열로 데이터의 변조가 발생하였다. 이대로 못 쓸 수준은 아니라고 생각할 수도 있겠지만, 아무튼 완전 무결한 깊은 복사는 아니라는 것. 물론 이를 해결하기 위해 또 if문을 추가해가며 깊은 복사 로직을 더 완벽하게 만들 수는 있다. 하지만 모든 에지 케이스를 고려해야 한다는 것이 여간 귀찮은 일이 아니다.

#### 소개합니다 structuredClone

structuredClone()

코드와 함께 소개
HTML DOM API에서 정의한 Structured Clone Algorithm을 사용함. 데이터 변조 없이 깊은 복사를 수행하는 알고리즘. 이쪽도 재귀를 사용함.

속도 차이 비교도 넣으면 좋을 듯. 터무니없이 큰 JSON을 하나 가져다놓고.

### Hack the structuredClone

1. 비교적 최신기술. 물론 말이 비교적이지 소개된지 2년 넘긴 했다. 특별히 주의해야 할 사항은 Node에서는 17버전 부터 쓸 수 있다는 점. 그래서 백준에서는 아직 쓸 수 없다.
2. ECMA Script가 아니라 HTML DOM API에서 정의되어 있다.
   1. [이걸 궁금해하는 나같은 사람도 있긴 한듯.](https://es.discourse.group/t/structuredclone-as-ecmascript-standard/1661)
   2. 그래서 그런지 실패 시 DOMException을 반환한다.
   3. 사실 Web Worker, Indexed DB 등의 기능과 밀접한 관계를 맺고 있기 때문.
3. StructuredClone이 복사하지 못하는 데이터도 있다. 객체 안에 함수가 들어있는 경우 오류를 반환함. (Function object could not be cloned)

그냥 객체에 대한 깊은 복사를 해주는 API 라고 쉽게 설명할 수 있지만, 파고들수록 아주 어려운 내용들이 나온다.

## 내가 배운 것

일단 짚고 넘어야 할 부분은, 애초에 깊은 복사는 비싼 연산이란 점이다. 배열에 대해 깊은 복사를 수행한다면 그 배열의 요소 수 만큼 연산을 해야한다. 메모리도 2배로 필요하다. 프로그래밍 언어를 설계할 때 참조형 데이터는 주소값을 복사하도록 만든게 괜히 그런것은 아니라는점.  

---

  - 깊은복사 vs 얕은복사
  - 깊은복사가 필요한 이유
  - 기존방식
    - 직접구현
    - 외부라이브러리

  - 기존 js는 깊은 복사를 비효율 적인 방식 or 다른 외부 라이브러리에 의존했으나
    structuredClone이란 표준이 존재함
  - 대부분의 브라우저에서 지원하고, node는 17버전에서부터 지원
  - Node 17버전의 새로운 기능을 알아보자
  - 하지만 백준은 node 버전이 딸린다는 점 주의


structuredClone의 내부 구조
```
Structured Clone Algorithm의 의사코드는 웹 표준 문서인 HTML Living Standard에 자세히 기술되어 있습니다. 이 의사코드는 꽤 복잡하고 길기 때문에, 아래에는 알고리즘의 핵심적인 부분을 간략하게 요약한 내용을 제공하겠습니다.

1. 입력 값이 특정 타입(예: 기본 타입, 날짜 객체, 배열 등)인 경우, 해당 타입에 대한 복제 과정을 수행합니다.
2. 입력 값이 Map이나 Set과 같은 컬렉션 타입인 경우, 모든 항목을 순회하며 각 항목에 대한 복제 과정을 수행한 후, 이를 새로운 컬렉션에 추가합니다.
3. 입력 값이 일반 객체인 경우, 모든 속성을 순회하며 각 속성에 대한 복제 과정을 수행한 후, 이를 새로운 객체에 추가합니다.

이 때, 복제 과정은 Structured Clone Algorithm을 재귀적으로 호출하여 수행되며, 이를 통해 객체의 중첩된 모든 부분이 깊게 복사됩니다. 또한, 특정 타입의 값(예: 함수, 오류 객체 등)은 복제할 수 없으므로, 이러한 값이 포함된 경우에는 에러를 발생시킵니다.

정확한 의사코드는 HTML Living Standard 문서의 "StructuredClone" 섹션에서 확인하실 수 있습니다. 이 문서는 웹 표준을 정의하고 있으므로, 가장 신뢰할 수 있는 정보를 제공합니다.
```
여기도 재귀 쓰는건 똑같음

HTML DOM API 소속임 (왜?)
```
`structuredClone()`이 HTML DOM API에 포함되는 이유는 이 함수가 웹 브라우저 환경에서의 데이터 복제와 전송에 중요한 역할을 하기 때문입니다.

웹 브라우저 환경에서는 여러 API를 통해 데이터를 복제하거나 전송해야 하는 상황이 자주 발생합니다. 예를 들어, `postMessage()` API는 웹 워커나 다른 윈도우에 데이터를 전송할 때, IndexedDB는 복잡한 데이터 구조를 저장할 때, `history.pushState()`는 브라우저 히스토리에 상태를 추가할 때 Structured Clone Algorithm을 사용합니다.

이러한 상황에서 안전하게 데이터를 복제하고 전송하려면, 복제 과정에서 원본 데이터가 변경되지 않아야 하며, 데이터의 구조와 타입에 관계 없이 정확하게 복제되어야 합니다. `structuredClone()` 함수는 이러한 요구사항을 충족시키기 위해 설계되었으며, 이를 위해 내부적으로 Structured Clone Algorithm을 사용합니다.

따라서, `structuredClone()` 함수는 웹 브라우저 환경에서의 데이터 복제와 전송에 필수적인 역할을 하므로, HTML DOM API에 포함되어 있습니다. 이 함수를 사용하면 원본 데이터를 변경하지 않고도 안전하게 데이터를 복제하고 전송할 수 있습니다.
```

structuredClone()은 HTML DOM API에 포함되어 있는데 JSON.parse()는 ECMAScript 표준에 정의되어 있음. 미묘한 관계. 물론 목적이 다르긴 해서. JSON.parse()는 좀 더 JavaScript에 집중된 기능이라면, structuredClone()은 웹 워커나 IndexedDB 같은 브라우저의 기능에서 객체가 온전하게 전달될 수 있도록 관여해야함.
HTML Living Standard vs ECMAScript(ES)  
[이걸 궁금해하는 나같은 사람도 있긴 한듯.](https://es.discourse.group/t/structuredclone-as-ecmascript-standard/1661)

그리고 Node가 HTML DOM API의 영향을 받는건 이상한게 아님. fetch, addEventListener같은 API도 있고. window나 document같은건 못쓰지만.

 To keep things simple, for now we decide between dense and sparse serialization based on elements kind. A more principled heuristic could count the elements, but would need to take care to note which indices existed (as only indices which were enumerable own properties at this point should be serialized).

```
Maybe<bool> ValueSerializer::WriteJSArray(Handle<JSArray> array) {
  PtrComprCageBase cage_base(isolate_);
  uint32_t length = 0;
  bool valid_length = Object::ToArrayLength(array->length(), &length);
  DCHECK(valid_length);
  USE(valid_length);

  // To keep things simple, for now we decide between dense and sparse
  // serialization based on elements kind. A more principled heuristic could
  // count the elements, but would need to take care to note which indices
  // existed (as only indices which were enumerable own properties at this point
  // should be serialized).
  const bool should_serialize_densely =
      array->HasFastElements(cage_base) && !array->HasHoleyElements(cage_base);
```

**stringify, structuredClone** 둘 다 깊은 복사에 직렬화를 사용하는 방식.

https://github.com/v8/v8/blob/04f51bc70a38fbea743588e41290bea40830a486/src/objects/value-serializer.h
structuredClone은 내부적으로 이렇게 구현되어 있음(V8 엔진의 경우).