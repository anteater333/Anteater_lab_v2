---
layout: post
title: "자잘한 도움말 #13 Javascript에서 중첩된 객체에 대한 깊은 복사"
subtitle: "structuredClone() 쓰세요."
description: ""
date: 2023-12-06 11:00:00 +0900
categories: [Micro]
---

## TL;DR

- 참조 타입의 얕은 복사 vs 깊은 복사
  - 얕은 복사 : 데이터의 주소만 복사한다.
  - 깊은 복사 : 데이터의 값을 복사해 새로운 메모리에 할당한다.
- 중첩 구조를 가지는 객체에 대해서는 제대로 된 깊은 복사를 구현하기 까다롭다.
  ```javascript
  const original = { a: 1, b: 2, c: new Date() };
  const deepCopied = JSON.parse(JSON.stringify(original));
  // deepCopied.c는 문자열
  ```
  - 이렇게 `JSON.parse()`와 `JSON.stringify()`를 사용해 구현할 순 있지만 특정 상황에서 제대로 동작하지 않을 수 있다.

- Web API [`structuredClone()`](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone)을 사용하자.  
  ```javascript
  const original = { a: 1, b: 2, c: new Date() };
  const deepCopied = structuredClone(original);
  // deepCopied.c는 Date 객체
  ```
- 2023년 기준 비교적 최신 기술이기 때문에 사용 중인 자바스크립트 실행 환경의 [지원 현황](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone#browser_compatibility)을 확인하고 사용해야 한다.
  - 대표적으로 node.js는 17 버전부터 지원한다.
  - [백준의 node.js 버전은 2023년 기준 v16.13.1이기 때문에](https://help.acmicpc.net/language/info) 이 API를 사용할 수 없다.

---

## 이하 그리 중요하진 않은 내용들

## 내가 배운 것

---

  - 깊은복사 vs 얕은복사
  - 깊은복사가 필요한 이유
  - 기존방식
    - 직접구현
    - 외부라이브러리

  - 기존 js는 깊은 복사를 비효율 적인 방식 or 다른 외부 라이브러리에 의존했으나
    structuredClone이란 표준이 존재함
  - 대부분의 브라우저에서 지원하고, node는 17버전에서부터 지원
  - Node 17버전의 새로운 기능을 알아보자
  - 하지만 백준은 node 버전이 딸린다는 점 주의


structuredClone의 내부 구조
```
Structured Clone Algorithm의 의사코드는 웹 표준 문서인 HTML Living Standard에 자세히 기술되어 있습니다. 이 의사코드는 꽤 복잡하고 길기 때문에, 아래에는 알고리즘의 핵심적인 부분을 간략하게 요약한 내용을 제공하겠습니다.

1. 입력 값이 특정 타입(예: 기본 타입, 날짜 객체, 배열 등)인 경우, 해당 타입에 대한 복제 과정을 수행합니다.
2. 입력 값이 Map이나 Set과 같은 컬렉션 타입인 경우, 모든 항목을 순회하며 각 항목에 대한 복제 과정을 수행한 후, 이를 새로운 컬렉션에 추가합니다.
3. 입력 값이 일반 객체인 경우, 모든 속성을 순회하며 각 속성에 대한 복제 과정을 수행한 후, 이를 새로운 객체에 추가합니다.

이 때, 복제 과정은 Structured Clone Algorithm을 재귀적으로 호출하여 수행되며, 이를 통해 객체의 중첩된 모든 부분이 깊게 복사됩니다. 또한, 특정 타입의 값(예: 함수, 오류 객체 등)은 복제할 수 없으므로, 이러한 값이 포함된 경우에는 에러를 발생시킵니다.

정확한 의사코드는 HTML Living Standard 문서의 "StructuredClone" 섹션에서 확인하실 수 있습니다. 이 문서는 웹 표준을 정의하고 있으므로, 가장 신뢰할 수 있는 정보를 제공합니다.
```
여기도 재귀 쓰는건 똑같음

HTML DOM API 소속임 (왜?)
```
`structuredClone()`이 HTML DOM API에 포함되는 이유는 이 함수가 웹 브라우저 환경에서의 데이터 복제와 전송에 중요한 역할을 하기 때문입니다.

웹 브라우저 환경에서는 여러 API를 통해 데이터를 복제하거나 전송해야 하는 상황이 자주 발생합니다. 예를 들어, `postMessage()` API는 웹 워커나 다른 윈도우에 데이터를 전송할 때, IndexedDB는 복잡한 데이터 구조를 저장할 때, `history.pushState()`는 브라우저 히스토리에 상태를 추가할 때 Structured Clone Algorithm을 사용합니다.

이러한 상황에서 안전하게 데이터를 복제하고 전송하려면, 복제 과정에서 원본 데이터가 변경되지 않아야 하며, 데이터의 구조와 타입에 관계 없이 정확하게 복제되어야 합니다. `structuredClone()` 함수는 이러한 요구사항을 충족시키기 위해 설계되었으며, 이를 위해 내부적으로 Structured Clone Algorithm을 사용합니다.

따라서, `structuredClone()` 함수는 웹 브라우저 환경에서의 데이터 복제와 전송에 필수적인 역할을 하므로, HTML DOM API에 포함되어 있습니다. 이 함수를 사용하면 원본 데이터를 변경하지 않고도 안전하게 데이터를 복제하고 전송할 수 있습니다.
```

structuredClone()은 HTML DOM API에 포함되어 있는데 JSON.parse()는 ECMAScript 표준에 정의되어 있음. 미묘한 관계. 물론 목적이 다르긴 해서. JSON.parse()는 좀 더 JavaScript에 집중된 기능이라면, structuredClone()은 웹 워커나 IndexedDB 같은 브라우저의 기능에서 객체가 온전하게 전달될 수 있도록 관여해야함.
HTML Living Standard vs ECMAScript(ES)  
[이걸 궁금해하는 나같은 사람도 있긴 한듯.](https://es.discourse.group/t/structuredclone-as-ecmascript-standard/1661)

그리고 Node가 HTML DOM API의 영향을 받는건 이상한게 아님. fetch, addEventListener같은 API도 있고. window나 document같은건 못쓰지만.

 To keep things simple, for now we decide between dense and sparse serialization based on elements kind. A more principled heuristic could count the elements, but would need to take care to note which indices existed (as only indices which were enumerable own properties at this point should be serialized).

```
Maybe<bool> ValueSerializer::WriteJSArray(Handle<JSArray> array) {
  PtrComprCageBase cage_base(isolate_);
  uint32_t length = 0;
  bool valid_length = Object::ToArrayLength(array->length(), &length);
  DCHECK(valid_length);
  USE(valid_length);

  // To keep things simple, for now we decide between dense and sparse
  // serialization based on elements kind. A more principled heuristic could
  // count the elements, but would need to take care to note which indices
  // existed (as only indices which were enumerable own properties at this point
  // should be serialized).
  const bool should_serialize_densely =
      array->HasFastElements(cage_base) && !array->HasHoleyElements(cage_base);
```

**stringify, structuredClone** 둘 다 깊은 복사에 직렬화를 사용하는 방식.

https://github.com/v8/v8/blob/04f51bc70a38fbea743588e41290bea40830a486/src/objects/value-serializer.h
structuredClone은 내부적으로 이렇게 구현되어 있음(V8 엔진의 경우).