---
layout: post
title: "자잘한 도움말 #16 useMemo로 컴포넌트를 메모하지 맙시다."
subtitle: "useMemo vs React.memo"
description: ""
date: 2024-05-01 16:50:00 +0900
categories: [Micro]
---

## TL;DR

- 

---

## 이하 그리 중요하진 않은 내용들

내가 당연하다는듯이 써왔던 안티 패턴에 대하여

## 내가 배운 것


---
- React.memo를 써래
    - 이건 HOC를 만들어냄
        - HOC가 뭔데…?
    - prop이 변경될 때만 다시 렌더링되도록 만들어준다
- 그럼 useMemo를 굳이 쓰지 말아야하는 이유는..?
    
    [Hooks - useMemo](https://velog.io/@hyeon9782/Hooks-useMemo)

```
동작은 동일합니다. visibleTodos가 변경되지 않은 경우 List가 리렌더링되지 않습니다.
같은 JSX 노드는 { type: List, props: { items: visibleTodos } }와 같은 객체입니다.
이 객체를 생성하는 것은 비용이 적게 들지만, React는 그 내용이 지난번과 동일한지 아닌지 알지 못합니다. 그렇기 때문에 기본적으로 React는 List 컴포넌트를 다시 렌더링합니다.
하지만 React는 이전 렌더링 때와 동일한 JSX를 발견하면 컴포넌트를 리렌더링하려고 시도하지 않습니다. JSX 노드는 불변이기 때문입니다.
JSX 노드 객체는 시간이 지나도 변경될 수 없으므로 React는 리렌더링을 건너뛰어도 안전하다는 것을 알고 있습니다. 다만 이것이 작동하려면 노드가 단순히 코드에서 동일하게 보이는 것이 아니라 실제로 동일한 객체여야 합니다. 이 예시에서 useMemo는 바로 이런 역할을 합니다.
JSX 노드를 수동으로 useMemo로 감싸는 것은 편리하지 않습니다. 예를 들어, 이 작업을 조건부로 수행할 수 없습니다. 일반적으로 JSX 노드를 useMemo로 감싸는 대신 memo로 컴포넌트를 감싸는 이유입니다.(이 부분이 중요하네요 ㅎㅎ )
```