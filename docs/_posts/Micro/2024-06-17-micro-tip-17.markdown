---
layout: post
title: "자잘한 도움말 #17 페이지 이탈 방지 React 커스텀 훅 구현하기"
subtitle: "React 메모이제이션 연작 제 2편 - 참조 동일성"
description: "참조동일성, 참조 동일성, beforeunload, 새로고침 방지, 페이지 이탈 방지, React, 리액트, usePreventLeave, 메모이제이션, useCallback"
date: 2024-06-17 18:30:00 +0900
categories: [Micro]
---

## TL;DR
![leave site?](https://i.postimg.cc/W1G0zZv2/image.png)  
{: .center .w-half .rounded-edge-16}

- 현재 페이지에서 다른 페이지로 이동하거나 웹 페이지를 새로고침 할 때 사용자에게 확인 메시지를 표시하고 싶을 경우 `beforeunload` 이벤트를 사용한다.

```javascript
window.addEventListener("beforeunload", function (event) {
  event.preventDefault();
  event.returnValue = true;
});
```

- React 커스텀 훅 형태로는 다음과 같이 만들 수 있다.

```javascript
import { useCallback } from 'react';

export function usePreventLeave() {
  const handler = useCallback((e) => {
    e.preventDefault();
    e.returnValue = true;
  }, []);

  /** 페이지 이탈 방지 활성화 */
  const enablePrevent = useCallback(
    () => window.addEventListener("beforeunload", handler),
    []);

  /** 페이지 이탈 방지 해제 */
  const disablePrevent = useCallback(
    () => window.removeEventListener("beforeunload", handler),
    []);

  return { enablePrevent, disablePrevent };
}
```

- 이 때 `handler`에 `useCallback`을 사용하지 않으면 의도하지 않은 동작이 발생할 수도 있다.
- 메모이제이션은 성능적 측면 이외에도 **참조 동일성**을 지키기 위해 사용하기도 한다.

## 이하 그리 중요하진 않은 내용들

내가 웹 프론트 개발자의 길을 가고 있는 이유에는 사실 "웹 서핑"을 당당히 취미 중 하나로 꼽을 수 있을 정도로 방대한 인터넷 사용량도 포함된다고 볼 수 있다. 나는 현직**그리고 무직**{: .small .text-deco-line-through .text-deco-weight-normal} 사이버 먕령으로서, 사소하면서도 크리티컬한 사용자 경험 몇 가지에 눈살을 찌푸린 적이 많다고 자부한다. 그리고 아마 그 중 가장 최악이 1시간 동안 쓴 글이 새로고침 한 번에 사라지는 일일 것이다.

### 사이트에서 나가시겠습니까?

![사이트에서 나가시겠습니까?](https://i.postimg.cc/C5r1Q3r5/image.png)  
**바보같이 이걸 봐놓고도 무심코 "나가기"를 눌러서 쓰던 글을 날린 경험도 많다.**{: .text-deco-weight-normal .text-deco-line-through .middle-small}
{: .center .w-half .rounded-edge-16}

그래서 필요한 것이 이 기능이다. 사용자가 기꺼이 다시 쓰기엔 너무 귀찮을 내용을 웹 페이지에서 작업하고 있을 땐, 그것이 실수 한 번에 사라지지 않도록 만들어줘야 한다. 다음과 같은 자바스크립트를 작성해 웹 페이지에 부착해주자.

```javascript
window.addEventListener("beforeunload", function (event) {
  event.preventDefault();
  event.returnValue = true;
});
```

[`beforeunload` 이벤트](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event){:target="_blank"}는 이름 그대로 불러왔던 리소스를 해제(unload)하기 직전 발생하는 이벤트다. 일반적으로 그 리소스는 접속한 페이지가 담겨있는 창(`window` 객체)을 뜻한다. 그래서 사용자가 현재 페이지에서 실수로 벗어나는 것을 막고자 할 때 이 이벤트를 사용하는 것이다.

페이지 이탈 확인 창은 `beforeunload` 이벤트에 전달된 핸들러가 다음과 같은 행동을 할 때 장전된다.

- `event` 객체의 `preventDefault()` 메소드를 호출할 때  
  기본적으로 권장하는 방식이다.
- `event` 객체의 `returnValue` 프로퍼티에 truthy 값을 할당할 때  
  일부 브라우저 호환성을 위해 위 방식과 병행하는 것이 좋다.
- 이벤트 핸들러 함수가 truthy 값을 반환할 때  
  이 방식은 `addEventListener`가 아닌 `onbeforeunload`를 사용했을 때에만 유효하다.

확인 창은 `alert()` 메소드를 호출했을 때 나타나는 그것과 같이 브라우저에서 구현해준다. 여기서 각 브라우저의 똑똑한 정도를 알 수도 있는데, 위에 예제 화면으로 올린 크롬의 경우 사용자의 이탈 시도가 "페이지 새로고침"인지 혹은 "페이지 종료"인지를 인식해 메시지 내용을 다르게 표시한다. 파이어폭스는 그런거 없더라고.

아무튼 참 쉽죠? 농담이 아니라 너무 쉬워서 이걸로 글을 마무리하긴 좀 아쉽다. "자잘한" 도움말에조차 못 넣겠다 싶을 수준.

### React에서 해보자

그렇다면 이걸 React에서 한 번 구현해보자. 커스텀 훅 형태로 만들어 언제 어디서든, 어떤 프로젝트에서든 그 코드를 가져와 재사용할 수 있도록 만들어두자.

```javascript
export function usePreventLeave() {
  const handler = (e) => {
    e.preventDefault();
    e.returnValue = true;
  };

  /** 페이지 이탈 방지 활성화 */
  const enablePrevent = () =>
    window.addEventListener("beforeunload", handler);

  /** 페이지 이탈 방지 해제 */
  const disablePrevent = () =>
    window.removeEventListener("beforeunload", handler);

  return { enablePrevent, disablePrevent };
}
```

이렇게 구현해 다음과 같이 사용해봤다.

```javascript
export default function App() {
  // ...

  // 앞서 구현해둔 Prevent Leave 커스텀 훅 사용
  const { enablePrevent, disablePrevent } = usePreventLeave();

  /** 어떤 기능이 동작하는 중에만 Prevent Leave 활성화 */
  useEffect(() => {
    if (isRunning) enablePrevent();
    else disablePrevent();
  }, [isRunning]);

  // ...
}
```

<p class="small text-deco-line-through">신경 쓰이는 부분이 있겠지만 뒷부분 전개를 위해 연출 좀 했습니다. 참아주십쇼.</p>

그리고 이 코드로 구현한 아래 데모 페이지를 한 번 조작해보자.

<div class="sandbox-container">
<iframe src="https://codesandbox.io/embed/l36dtq?view=preview&module=%2Fsrc%2FApp.js"
     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"
     title="usePreventLeave"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>
</div>

설명대로 버튼을 누르고 페이지 새로고침을 해보자. 샌드박스 안에서만 새로고침을 해도 좋고 지금 이 블로그 페이지를 새로고침해도 좋다. 앞서 설명했던 확인 창이 표시될 것이다.

### 참조 동일성

그럼 이렇게도 해볼까. 타이머를 실행 하고 -> 다시 버튼을 한 번 더 눌러 정지한 다음 -> 새로고침 해보자. 이번에도 확인 창이 표시될 것이다. 아니 타이머가 동작 중일 때만 확인 창이 나왔으면 했는데?!

꽤 큰 문제라고 볼 수 있다. 불쾌한 사용자 경험엔 "쓸데없는 확인 창 출력"도 들어 있을거라고 믿는다. 우리의 의도를 벗어난 이 현상을 해결하려면 어떻게 해야할까? 위 커스텀 훅 코드를 분석해보자.

![이미지](https://i.postimg.cc/JhHQYn8d/image.png)  
{: .center .rounded-edge-16}

<div class="sandbox-container">
<iframe src="https://codesandbox.io/embed/d9t2yq?view=editor&module=%2Fsrc%2Fhooks%2FusePreventLeave.js"
     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"
     title="usePreventLeave and useCallback"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>
</div>

<div class="sandbox-container">
<iframe src="https://codesandbox.io/embed/d9t2yq?view=preview&expanddevtools=1"
     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"
     title="usePreventLeave and useCallback"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>
</div>

## 내가 배운 것

----
- React에서 usePreventLeave 구현하기
    - Well-Known 문제지만
        - useCallback을 쓰지 않는 예제가 넷상에 많다.
    - 문제 상황 재현하기
    - useCallback을 어떻게 써야 하는가?
    - **참조동일성**이란 키워드에 대해
    - 직전 글과 직접 비교를 하면서 두 상황에 대한 이야기를 나눠보는것도 좋을듯.
    - React 메모이제이션 2부작

prevent leave 자체는 아주 사소한 주제. 이렇게 글로 쓸 필요도 없음.

Custom Hook으로 만들어보자 (여기선 의도적으로 useCallback을 제외)

문제 상황 발생
사실 그 불쾌한 사용자 경험중 하나에 쓸데없는 확인 메시지 출력도 있거든.

useCallback을 쓰는 이유
참조 동일성에 대해

그리고 마지막으로 사실 useEffect를 좀 더 제대로 썼으면 굳이...