---
layout: post
title: '독후감 #1 클린 아키텍처'
subtitle: 'by 로버트 C. 마틴'
date: 2022-04-11 22:22:00 +0900
categories: [Reddit]
---

## 첫 개시, 첫 게시

![실물](https://i.postimg.cc/5N80twpP/Kakao-Talk-20220419-113127818.jpg)  
멋진 구도가 딱히 생각이 안나서 차라리 매니악하게
{: .center}

양심고백, 3월 초 책을 다 읽고 11일 경에 독후감을 작성해야지 다짐하며 목차를 작성해 뒀으나, 그로부터 한 달이 훌쩍 넘은 상태에서 글을 시작하고 있다. 블로그 관련해서 들었던 조언 중에 "텀이 길어도 되니까 주기적으로 글을 작성하라"는 말씀이 있었는데... 아무튼 그 덕택에 기억이 온전하진 않다. 양해를 미리 구하고 시작하겠다.

## 첫 책

독후감을 어떻게 써야 할 지 상상만 하던 때 부터, 그 시작은 왜 이 책을 선택하였는가에 대해 정리하는 것으로 하고싶었다. 왜냐하면, 지금 내가 가진 책이 좀 많다. 좋은 기회가 있어서 개발 관련 서적을 잔뜩 구매할 수 있었고, 사실 좀 충동적으로 지른게 많긴 해. 그렇다면 프론트/백엔드/인프라/AI 장르 불문 다양한 책들 중에서 나는 왜 하필 클린 아키텍처를 첫 번째 책으로 결정했나. 정리해보자.

![야그니](https://i.postimg.cc/CKpQg523/yagni.png)  
최근 개인 프로젝트 하면서도 꾸준히 이러고 있다.
{: .center}

첫 번째, [의존성 주입을 주제로 한 글](https://anteater333.github.io/hack/2022/03/07/hack-the-terms-1.html)에서도 언급했지만, 내가 소프트웨어 개발이란 길을 걸으면서 조금이나마 관심을 가지고 있다고 말할 수 있을만한 분야는 **소프트웨어 공학**이다. 그 덕에 나는 어느 정도 이쁜 설계의 필요성에 대해 자각은 가지고 있는 것 같다. 그런데 내가 항상 무언가를 만들면서 머리를 싸매고 고민하는 것은, **"이게 좋은 패턴인가?"** 라는 걱정이다. 타고난 기질이 혼자 조용히 깨작대는 것인 나는, 지금 내가 만들어놓은 이 코드 덩어리가 보기에 이쁜 모양인지에 대해 객관적인 판단을 하는데에 많은 어려움을 겪고 있는 상황인 것이다.

둘째로, 나는 이것저것 하는걸 좋아한다. 소프트웨어 공학을 좋아하는 이유도 그런 점이라고 생각한다. 개발, 정확히는 **소프트웨어 개발** 이라는 것이 GUI가 달린 클라이언트 어플리케이션을 만드는 것일 수도 있고, 백엔드에서 동작할 서버 어플리케이션을 만드는 것일 수도 있다. 혹은 꼭 코드를 많이 작성하는 것 뿐만이 아니라 서비스를 위한 인프라를 구성하는 것도 개발일 수 있고, 데이터베이스를 주로 다루는 개발자도 있겠지. 아니면 다른 단위로 묶어볼 수도 있다. 인공지능, 블록체인, 게임, 웹서비스, 데이터 처리, 등등등등 이런 수많은 가능성이 있는 것이 개발이 아닐까. 그리고 이 가능성들의 최상위 공통점이 바로 "소프트웨어"라고 생각한다.  

나는 소프트웨어 개발자(지망생)로써 여러 개발 분야들을 이것저것 찔러보는 편이다. 웹 프론트도 해보고, 백엔드도 해보고, 작년엔 데이터 처리도 했고, 버킷리스트 중 하나는 게임 개발이고, 지금은 개인 프로젝트로 모바일 어플리케이션을 개발하고 있다. 이렇게 줏대없이 여러가지 해왔다 보니 일반적인 소프트웨어 설계에 대한 호기심이 생겨난 것 같다. 뭘 만들든 일단 소프트웨어인데, 소프트웨어 관점에서 잘 설계된 구조는 무엇일까? 싶었던 것이다.

[![밥아저씨](https://i.postimg.cc/htqb7DHY/robert.png)](https://www.google.com/search?q=Uncle+bob)
{: .center}

그리고 마지막으로, 내가 산 책 중에서 가장 유명했다. 잘 모르겠을땐 역시 유명한 쪽으로.

## 옛날 이야기

![자바](https://i.postimg.cc/yxGj19Ym/java.jpg)  
{: .center}

고등학생 시절 프로그래머가 되고 싶다고 주변 친구들에게 말하면 다음과 같은 놀림을 받을 수 있었다.

*"요즘 프로그래머가 얼마나 힘든줄 알아? 어디 인력사무소 같은 곳에서 드럼통 모닥불 쬐며 기다리고 있다가 봉고차 한 대 와가지고 "2명 타요!" 하면 거기 실려가는 처지라더라!"*   

물론 저 때가 2010년대 초였고, 알파고니 비트코인이니 하는 단어들, 그리고 디지털 트랜스포메이션 어쩌구 하는 흐름들은 왠만하면 접할 수 없던 시대였으니 어느 정도 시대적 상황을 감안해서 받아들일 만한 농담이라고 생각한다. 지금은 취업도 잘된다고 하고, 초봉도 높다고 하고 상황이 많이 좋아지긴 했다. 그럼에도 불구하고 저 *"Java 두명 타요!"* 조크가 자조적으로 쓰이는 것을 아직도 가끔씩 발견할 수 있다. 시대가 아무리 발전하고 이 시장에 아무리 젖과 꿀이 흐르고 있다고 한들, 사실 프로그래머의 역할이 크게 바꼈다는 생각은 안든다. 이 책의 초반에서는 지금까지 이뤄진 프로그래밍 패러다임의 변화를 설명한 끝에 이렇게 표현하고 있다.

> ... 우리는 환영받지 못할 사실, 즉 소프트웨어는 급격히 발전하는 기술이 아니라는 진실과 마주하게 된다. ... 소프트웨어, 즉 컴퓨터 프로그램은 순차, 분기, 반복, 참조로 구성된다. 그 이상도 이하도 아니다.

안타까운 현실, 프로그래머로써의 우리는 언제든 대체될 수 있다. 좀 더 젊고, 손이 빠르고, 순간순간의 문제에서 더 효율적으로 처리할 수 있는 사람들에게. 주제넘은 소리겠지만, 가끔씩은 여기에 어떠한 두려움이 존재한다고 느껴진다. 나는 그저 "코더"에 불과할 지도 모른다. 어느 순간부터 나는 스스로를 프로그래머라고 소개하기 보단 소프트웨어 개발자라고 칭하는 것에 익숙해지고 있다. 프로그램(좀 더 코드에 가까운 뉘앙스로 다가온다)을 짜는 사람이 아니라, 좀 더 고차원적인 것을 만드는 사람이 되고싶은 것은 아닐까.

## 아키텍트

![아키텍트](https://i.postimg.cc/SQ9PZjGp/a.jpg)  
매트릭스도 이제 오래되긴 했어...
{: .center}

이 상황에서 우리의 동경을 불러일으키는 단어가 있으니, 바로 **아키텍트**이다. **시스템의 설계자**라는 칭호는 단순히 더 젊은 두뇌만으로 차지할 수 있을 만한 것이 아닌 것 처럼 느껴진다. 수많은 경험과 그 결과로 얻어낸 지식을 바탕으로 될 수 있는 것이 **아키텍트**인 것이다. 하지만 앞서 말했듯이 소프트웨어는 생각보다 급격히 발전하는 기술이 아니다. 지긋한 백발의 현인들이 가진 지식은 글로 쓰여저 전수되는 중이고, 여전히 유효하다. 우리는 그 수많은 시간이 필요한 경험들을 굳이 우리 생에 걸쳐 겪지 않아도 단편적으로나마 체험할 수 있는 것이다. 그 경험의 끝에서 그들이 검증한 좋은 설계, 즉 아키텍처가 도출되며, 엉클 밥의 **클린 아키텍처**는 그 중 하나인 것이다.

## 코드, 정책Policy 그리고 세부사항Detail

이렇게까지 이야기 했지만, 정작 책에서 일깨워주는 중요한 사실은 바로 **아키텍트는 여전히 프로그래머**라는 것이다. 마치 아키텍트는 코드와는 전혀 관계없는 고수준의 논의를 해야할 것 처럼 느껴지겠지만, 아키텍트는 여전히 코드를 다뤄야 한다. 그들의 경험이란 코드이다. 클린 아키텍처는 여기서 시작하는 것 같다. 소프트웨어 아키텍처의 목표가 그저 "시스템을 제대로 동작하도록 만드는데"에 멈춰있어선 안되는 것이다. 물론 저 목표도 상당히 옳은 말이지만, 저 목표엔 코드가 포함되어있지 않다.

아키텍처는 시스템을 이루는 컴포넌트(재사용 가능한 각각의 독립된 모듈)들이 나타내는 형태이고, 그 형태는 소프트웨어 시스템이 쉽게 개발, 배포, 운영, 유지보수될 수 있는 방향으로 만들어진다. **즉 소프트웨어(Software)는 부드럽게(Soft) 유지되어야 한다.** 그리고 소프트웨어가 부드럽게 유지되기 위해서는 **세부사항에 대한 선택을 가능한 한 많이, 가능한 한 오랫동안 열어둬야 한다**고 책에서는 설명한다. 모든 소프트웨어 시스템은 **정책**과 **세부사항**으로 분해할 수 있는데, 이렇게 분해한 후 세부사항은 뒤로 미뤄둔 채 고수준의 정책을 만들 수 있도록 해야 한다는 말이다. 그 결과 세부사항에 대한 결정을 오랫동안 참아가며 더 많은 정보를 얻을 수 있고, 그 정보를 토대로 더욱 제대로 된 결정을 내릴 수 있게 만든다는 것이다.

> - 개발 초기에는 데이터베이스 시스템을 선택할 필요가 없다.  
>   고수준의 정책은 어떤 종류의 데이터베이스를 사용하는지 신경 써서는 안 된다.
> - 개발 초기에는 웹 서버를 선택할 필요가 없다.  
>   고수준의 정책은 자신이 웹을 통해 전달된다는 사실을 알아서는 안 된다.
> - 개발 초기에는 REST를 적용할 필요가 없다.  
>   고수준의 정책은 외부 세계로의 인터페이스에 대해 독립적이어야 하기 때문이다.
> - 개발 초기에는 의존성 주입 프레임워크를 적용할 필요가 없다.  
>   고수준의 정책은 의존성을 해석하는 방식에 대해 신경 써서는 안 된다.

> **좋은 아키텍트는 결정되지 않은 사항의 수를 최대화한다.**

## 프레임워크와 결혼하지 마라

![결혼하지마](https://i.postimg.cc/0Q1k2DYp/image.jpg)
{: .center}

자, 다시. 아키텍처는 정책과 세부사항으로 이루어진다. 그렇다면 그 둘을 통해 아키텍처는 무엇을 말하는가. **아키텍처는 그 스스로 소리쳐야 된다.**

> 이 아키텍처는 "헬스 케어 시스템이야" 또는 "재고 관리 시스템이야"라고 소리치는가? 아니면 "레일스야", "스프링/하이버네이트야", 아니면 "ASP야"라고 소리치는가?

아키텍처는 그 자체로 존재하고, 스스로 본인의 존재를 증명한다. 아키텍처의 정책들은 유스케이스의 형태로 이것이 어떤 서비스에 대한 아키텍처인지 다방면으로 설명해줘야 한다. 세부사항은 그 정책들이 어떠한 방식으로 구현될지에 대해 설명할 것이다. 이 어떠한 방식들에 React, Spring 따위의 프레임워크들이 들어갈 수 있는 것이다. 즉 아키텍처는 특정 프레임워크로부터 제공받을 수 없는 것이다. 아키텍처를 위해 프레임워크라는 도구가 존재하는 것이지, 프레임워크 그 자체가 아키텍처가 될 수는 없고, 그래서는 안된다. 그걸 프레임워크와 결혼하지 말라는 표현으로 말하는 것이다. 현대 프레임워크들은 종종 사용자에게 너무 강한 결합(Coupling)을 요구해서 우리가 그와 결혼까지 고민해야 하도록 만들곤 한다.

[얼마 전 이런 글을 봤다.](https://news.hada.io/topic?id=6395)  
{: .middle-big .center}
물론 [원글](https://medium.com/codex/the-javascript-framework-war-is-over-bd110ddab732)의 댓글을 보면 알겠지만 상당히 반발이 심하긴 하다...
{: .center}

요약하자면, React가 자바스크립트 프레임워크 전쟁의 승자로 뽑힐 수 있는 이유는 스스로를 사용자 코드에서부터 제거하기 때문이라고 한다. 여러모로 이 클린 아키텍처의 내용이 생각나는 글이었다.

조금은 이상적이고 추상적이기만 한 이야기처럼 들릴 수도 있겠단 생각이 든다. 하지만 이 논의들의 결과로 아키텍처가 정책을 설명하는 유스케이스를 최우선으로 두고, 프레임워크와는 적당한 거리를 두도록 만듦으로써, 프레임워크를 전혀 준비하지 않더라도 유스케이스 전부에 대해 단위 테스트를 할 수 있는 아키텍처가 탄생하는 것이다. 즉, **테스트하기 쉬운 아키텍처**가 탄생하는 것이다.

## 클린 아키텍처Clean Architecture

![클린 아키텍처](https://i.postimg.cc/MTJVCzDd/Clean-Architecture.jpg)
{: .center}

클린 아키텍처



## 기억에 남는 내용

[다음 책 예고]


이거 내용도 넣기
https://techblog.woowahan.com/2647/